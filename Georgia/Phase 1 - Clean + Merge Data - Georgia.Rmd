---
title: "Phase 1: Clean & Merge Data - Georgia"
author: "Emma Klugman"
date: "`r Sys.Date()`"
output: pdf_document
urlcolor: blue
---

This file does the following:

*    reads in multiple years of student-level data
*    cleans it according to our analysis specifications
*    reads in school-level data, including accountability indices
*    merges school-level and student-level data, according to our analysis specifications
*    exports the cleaned and merged data for our later analyses

```{r setup, include = FALSE}
# This chunk loads in some helpful packages, but doesn't print out any info about that. 

library(tidyverse)    # Great for data manipulation, cleaning, and joining
library(janitor)      # Has a lovely "get_dupes" function I'll use
library(readxl)
library(skimr)        # Has a beautiful summary function, "skim()"
```

# Cleaning student-level data

In this section, we ensure that our student-level data is formatted exactly how we expect, contains only values that make sense, and is ready for merging. 

Before any of these standard steps can take place for any given state, I'll want to check that our columns all seem to contain the data types we're expecting, and change the column names to common names for further processing. 

I'll also conduct various forms of exploratory data analysis to look for any unusual values in the data, for example -999 for NAs. 

## Reading in student-level data

We begin by reading in the student-level data from our Test state for the years 2016, 2017, and 2018. 

```{r reading_student_level_data, message = FALSE}
georgia_data <- read.table("Gates Walton_Georgia/Student Files/fy2016-2022_gmas-eog-detail-with-lexile_pipe.txt",
                           header = TRUE,
                           sep = "|", 
                           na.strings = "" )

nrow(georgia_data)
```

## Tidy and rename columns to standard form

SCHOOL_ID is NOT unique for schools in Georgia. 

We therefore create our own SchoolID variable that is bascially the concatenation of three things: County ID, School ID, Grade Cluster, 
that is "SYSTEM_ID" and "SCHOOL_ID" and a final letter of "E" or "M" for Grade Cluster. 

In school-level Georgia data, every school that serves students up to grade 5 have "E" accountability data, those with any students in grades 6-8 have "M" accountability data, and those serving grades 9 and up have "H" accountability data. Schools spanning acrosss these divides have multiple school-level accountability metrics across those different grade clusters. 

For SchoolIDs on the student-level data, therefore, we use the student's grade level, and assign an "E" tag if they're less than or equal to grade 5, and an M tag if they are at or above 6th grade. 

Valid SchoolIDs look like "6630199M", where the first three digits correspond to the county, the next four to the school, and the final letter to the grade cluster. 

```{r rename_student_columns_to_standard_form}

georgia_data <- georgia_data %>% 
    # If SYSTEM_ID already includes both county and school (is super long), make that our "SchoolID"
    # Otherwise, concatenate them together ourselves to create our SchoolID variable. 
    mutate(GRADE_CLUSTER = ifelse(STUDENT_GRADE_LEVEL < 6, "E", "M"),
           SchoolID = case_when(SYSTEM_ID > 1000  ~ 
                                    paste0(SYSTEM_ID, GRADE_CLUSTER),
                                TRUE ~ 
                                    paste0(SYSTEM_ID*10000 + SCHOOL_ID, GRADE_CLUSTER))) %>% 
    # rename uses new_name = old_name syntax
    rename(YEAR = SCHOOL_YEAR,
           ID = STUDENT_ID32,
           CONTENT_AREA = ASSESSMENT_SUBJECT_CODE,
           Race = RACE_ETHNICITY, 
           SWD = SWD_FLAG,
           EconDis = ECON_DISADVANTAGE_FLAG,
           EL = EL_FLAG,
           GRADE = STUDENT_GRADE_LEVEL,
           SCALE_SCORE = ASSESSMENT_SCALE_SCORE,
           ACHIEVEMENT_LEVEL = PERFORMANCE_LEVEL) %>% 
    # change the order of the columns to be our standard form
    relocate(YEAR, ID, CONTENT_AREA, Race, SWD, 
             EconDis, EL, SchoolID, GRADE, SCALE_SCORE, ACHIEVEMENT_LEVEL) %>% 
    # drop the columns we won't be using
    select(-c(SCHOOL_ID, SYSTEM_ID, ASSESSMENT_TYPE_CODE, 
              LEXILE_SCALE_SCORE, GRADE_CLUSTER))
```

## Remove invalid records

Valid SCALE_SCORE values for Georgia described here: https://www.gadoe.org/Curriculum-Instruction-and-Assessment/Assessment/Pages/Test_Score_Ranges.aspx

```{r removing_invalid_records}
# Initial record count
nrow(georgia_data)

# The "filter" function used below does row-wise deletion
georgia_data <- georgia_data %>% 
    filter(!is.na(ID)) %>% 
    filter(!is.na(SchoolID)) %>% 
    filter(Race %in% c("H", "I", "S", "B", "P", "W", "M")) %>% 
    filter(SWD %in% c("Y", "N")) %>% 
    filter(EconDis %in% c("Y", "N")) %>% 
    filter(EL %in% c("Y", "N")) %>% 
    filter(!is.na(GRADE)) %>% 
    filter(!is.na(SCALE_SCORE)) %>% 
    filter(!is.na(ACHIEVEMENT_LEVEL)) %>% 
    filter(CONTENT_AREA %in% c("E", "M")) %>% 
    filter(3 <= GRADE & GRADE <= 8)
    # No invalid SCALE_SCORE or ACHIEVEMENT_LEVELs found

# New record count
nrow(georgia_data)
```

## Rename groups to what the SGP package expects to see

```{r renaming_to_SGP_conventions}
# Rename groups to what the SGP package expects to see, using new_name = old_name syntax

georgia_data <- georgia_data %>% 
    mutate(Race = fct_recode(Race,
                    "Black" = "B",
                    "Hispanic" = "H", 
                    "Native American" = "I", 
                    "Multiracial" = "M",
                    "Pacific" = "P",
                    "Asian" = "S", 
                    "White" = "W"),
           ACHIEVEMENT_LEVEL = fct_recode(ACHIEVEMENT_LEVEL,
                    "Beginning Learner" = "BEG",
                    "Developing Learner" = "DEV", 
                    "Distinguished Learner" = "DIS", 
                    "Proficient Learner" = "PRO"),
           CONTENT_AREA = fct_recode(CONTENT_AREA,
                    "ELA" = "E",
                    "MATHEMATICS" = "M"),
           EconDis = fct_recode(EconDis,
                    "EconDis: No" = "N",
                    "EconDis: Yes" = "Y"),
           EL = fct_recode(EL,
                    "EL: No" = "N",
                    "EL: Yes" = "Y"),
           SWD = fct_recode(SWD,
                    "SWD: No" = "N",
                    "SWD: Yes" = "Y"))
```

## Checking for duplicates

Identify student records with duplicate ID and CONTENT_AREA combinations and keep the record with the higher scale score value.

```{r removing_student_level_duplicates}
# First, I'd wish to examine and count the duplicates to see what's going on, 
# which I can do with janitor::get_dupes
duplicates <- janitor::get_dupes(georgia_data, 
                                 ID, CONTENT_AREA, YEAR)
nrow(duplicates)

# How many students does this affect across all years?
length(unique(duplicates$ID))

# Now I'll go through the students for whom we have multiple scores, and keep records with the higher scale score values.
lower_scores_to_exclude <- duplicates %>% 
    group_by(ID, CONTENT_AREA, YEAR) %>% 
    # Within each student/subject/year, sort the scale scores highest to lowest
    arrange(desc(SCALE_SCORE)) %>% 
    # Identify the n-1 lowest scores for removal
    slice_tail(n = -1)

# Then, I can "anti_join" the full dataset with these "lower_scores_to_exclude"
# This drops any rows that were those poorer duplicates
georgia_data = anti_join(georgia_data, lower_scores_to_exclude)

rm(duplicates, lower_scores_to_exclude)
```

## Sort and save the cleaned-up student-level data records

```{r sorting_and_saving_student_level_data}
# Final record count
nrow(georgia_data)

georgia_data <- georgia_data %>% 
    arrange(YEAR, ID, CONTENT_AREA) %>% 
    write_csv(file = 
      "Georgia - 1 - Cleaned and Merged Data/Student_LongTestData_Georgia_2016-2022_EK.csv")
```






# Cleaning school-level data

The data cleaning tasks in steps 6 to 8 should be done only for the years of administration that are the focus on the study analysis (i.e., 2018 and 2019).

## Reading in school-level data

```{r reading_school_level_data, message = FALSE}
# First, I'll read in the Participation Rate data

# Note that I found that some of these Participation Rate values are listed as "No Data Found" (character)
# I'll read them in as NA (an R data type)
# schools_part_rates_18 <- read_xlsx("Gates Walton_Georgia/03.Participation Rates_2016-2021/Ga_2018_Participation Rates.xlsx",
#                                    na = "No Data Found")
# schools_part_rates_19 <- read_xlsx("Gates Walton_Georgia/03.Participation Rates_2016-2021/Ga_2019_Participation Rates.xlsx",
#                                    na = "No Data Found")
schools_part_rates_18 <-
    read_xlsx(
        "Data/03.Participation Rates_2016-2021/Ga_2018_Participation Rates.xlsx",
        na = "No Data Found"
    )
schools_part_rates_19 <-
    read_xlsx(
        "Data/03.Participation Rates_2016-2021/Ga_2019_Participation Rates.xlsx",
        na = "No Data Found"
    )
# Next, I'll read in the ELP Progress Data

# Note that I found that some of these ProgELP values are listed as "NA" (character)
# I'll read them in as NA (an R data type)
schools_ProgELP_18 <-
    read_xlsx(
        "Data/05.Progress in ELP_2016-2021/Ga_2018 CCRPI Progress Scores.xlsx",
        guess_max = 30000,
        na = "NA"
    )
schools_ProgELP_19 <-
    read_xlsx(
        "Data/05.Progress in ELP_2016-2021/Ga_2019 CCRPI Progress Scores.xlsx",
        guess_max = 5000,
        na = "NA"
    )

# Finally, I'll read in the SQSS data
schools_SQSS_18 <-
    read_xlsx(
        "Data/06.SQSS_2016-2021/ESSA_Readiness/Ga_2018 CCRPI Readiness Indicators by Subgroup 12_14_18.xlsx",
        guess_max = 200000,
        na = "NA"
    )
schools_SQSS_19 <-
    read_xlsx(
        "Data/06.SQSS_2016-2021/ESSA_Readiness/Ga_2019 CCRPI Readiness Indicators Data by Subgroup_10_25_19.xlsx",
        guess_max = 200000,
        na = "NA"
    )
```

## Tidy group names

We'll standardise the group names to match what we did with the student-level data above. This is especially important for this school-level data, since naming conventions vary across the files, e.g., "American Indian/Alaskan" and "American Indian/Alaskan Native", or "Students with Disability" and "Students With Disability". 

We'll do this as we go, to facilitate the best merge later across the multiple sources of school-level data we use. 

```{r standardise_group_names_school_level}
tidy_group_names <- function(df)
{
    df <- mutate(df, Group = fct_recode(Group,
            "Native American" = "American Indian/Alaskan",
            "Native American" = "American Indian/Alaskan Native",
            "Multiracial" = "Multi-Racial",
            "SWD" = "Students with Disability",
            "SWD" = "Students With Disability",
            "EL" = "English Learners",
            "EconDis" = "Economically Disadvantaged",
            "All" = "ALL Students",
            "Asian" = "Asian/Pacific Islander")
          )
    # TODO Figure out what to do with Georgia's combined "Asian/Pacific Islander" category. 
    return(df)
}
```

## Tidy participation data

```{r tidy_participation_data, warning = FALSE}

tidy_participation_data <- function(df)
{
    print(paste("Rows before any cleaning =", nrow(df)))

    # First, for Georgia data, I'll drop the CONTENT_AREAs that aren't Math and ELA
    df <- filter(df, ASSESSMENT_SUBJECT_AREA_CODE %in% c("English Language Arts", "Mathematics"))
    print(paste("Rows remaining after dropping invalid subjects =", nrow(df)))

    # And the schools that are high schools 
    df <- filter(df, GRADE_CLUSTER != "H")
    print(paste("Rows remaining after dropping high schools =", nrow(df)))

    # And drop the "ALL SCHOOLS" rows
    df <- filter(df, SCHOOL_ID != "ALL")
    print(paste("Rows remaining after dropping aggregated `ALL` schools rows =", nrow(df)))

    # Now that we've finished dropping invalid rows, we'll focus on column-level transformations. 

    # As above for the student-level data, we create our own unique SchoolID variable for Georgia
    df <- mutate(df, SchoolID = case_when(as.numeric(SYSTEM_ID) > 1000  ~ 
                                            paste0(SYSTEM_ID, GRADE_CLUSTER),
                                          TRUE ~ 
                                            paste0(as.numeric(SYSTEM_ID)*10000 + as.numeric(SCHOOL_ID), GRADE_CLUSTER)))

    # Then, I'll drop the columns we aren't interested in:
    df <- select(df, -c(SYSTEM_ID, SCHOOL_ID, SYSTEM_NAME, SCHOOL_NAME, 
                        GRADE_CONFIGURATION_CODE, NUMER_TESTED, 
                        NUMBER_REQUIRED_TO_TEST, SCHOOL_YEAR, GRADE_CLUSTER))

    # Georgia has separate rows for ELA and Math, where we'll instead want different columns
    df <- pivot_wider(data = df,
                     id_cols = c("SchoolID", "REPORTING_CATEGORY_CODE"),
                     names_from = ASSESSMENT_SUBJECT_AREA_CODE, 
                     values_from = PARTICIPATION_RATE,
                     names_prefix = "PartRate")

    # The transform above should halve the number of rows
    print(paste("Final rows remaining pivoting wider =", nrow(df)))

    # We'll rename and rearrange
    df <- df %>% 
        # rename uses new_name = old_name syntax
        rename(Group = REPORTING_CATEGORY_CODE,
               ELA_PartRate = "PartRateEnglish Language Arts",
               Math_PartRate = PartRateMathematics) %>% 
        # change the order of the columns to be our standard form
        relocate(SchoolID, Group, ELA_PartRate, Math_PartRate)

    # And finally, we'll standardise the group names
    df <- tidy_group_names(df)

    return(df)
}

schools_part_rates_18_tidied <- tidy_participation_data(schools_part_rates_18)
schools_part_rates_19_tidied <- tidy_participation_data(schools_part_rates_19)

rm(schools_part_rates_18, schools_part_rates_19, tidy_participation_data)
```

## Tidy ELP Progress data

```{r tidy_ProgELP_data, warning = FALSE}

tidy_ProgELP_data <- function(df)
{
    print(paste("Rows before any cleaning =", nrow(df)))

    # Remove the spaces in the column names, capitalise all
    df <- clean_names(df, case = "all_caps")

    # Drop high schools 
    df <- filter(df, GRADE_CLUSTER != "H")
    print(paste("Rows remaining after dropping high schools =", nrow(df)))

    # And drop the "ALL SCHOOLS" rows
    df <- filter(df, SCHOOL_ID != "ALL")
    print(paste("Rows remaining after dropping aggregated `ALL` schools rows =", nrow(df)))

    # Since the ONLY data we actually care about here is ProgELP, I'll drop those that are missing
    df <- filter(df, !is.na(INDICATOR_SCORE))
    print(paste("Rows remaining after dropping missing ProgELP values =", nrow(df)))

    # Now that we've finished dropping invalid rows, we'll focus on column-level transformations. 

    # As above for the student-level data, we create our own unique SchoolID variable for Georgia
    df <- mutate(df, SchoolID = case_when(as.numeric(SYSTEM_ID) > 1000  ~ 
                                            paste0(SYSTEM_ID, GRADE_CLUSTER),
                                          TRUE ~ 
                                            paste0(as.numeric(SYSTEM_ID)*10000 + as.numeric(SCHOOL_ID), GRADE_CLUSTER)))

    # Then, I'll drop the columns we aren't interested in:
    df <- select(df, -c(SYSTEM_ID, SCHOOL_ID, SYSTEM_NAME, SCHOOL_NAME, GRADE_CLUSTER,
                        GRADE_CONFIGURATION, INDICATOR, TARGET, FLAG, SCHOOL_YEAR))

    # We'll rename and rearrange
    df <- df %>% 
        # rename uses new_name = old_name syntax
        rename(Group = REPORTING_LABEL,
               ProgELP = INDICATOR_SCORE) %>% 
        # change the order of the columns to be our standard form
        relocate(SchoolID, Group, ProgELP)

    # And finally, we'll standardise the group names
    df <- tidy_group_names(df)

    return(df)
}

schools_ProgELP_18_tidied <- tidy_ProgELP_data(schools_ProgELP_18)
schools_ProgELP_19_tidied <- tidy_ProgELP_data(schools_ProgELP_19)

rm(schools_ProgELP_18, schools_ProgELP_19, tidy_ProgELP_data)
```

## Tidy SQSS data

For Georgia, we create our own SQSS variable, by taking the mean of the following indicators:
1) Literacy
2) Student Attendance
3) "Beyond the Core"

```{r tidy_SQSS_data, warning = FALSE}

tidy_SQSS_data <- function(df)
{
    print(paste("Rows before any cleaning =", nrow(df)))

    # Remove the spaces in the column names, capitalise all
    df <- clean_names(df, case = "all_caps")

    # Drop high schools 
    df <- filter(df, GRADE_CLUSTER != "H")
    print(paste("Rows remaining after dropping high schools =", nrow(df)))

    # And drop the "ALL SCHOOLS" rows
    df <- filter(df, SCHOOL_ID != "ALL")
    print(paste("Rows remaining after dropping aggregated `ALL` schools rows =", nrow(df)))

    # Drop indicators other than the three we're using
    df <- filter(df, INDICATOR %in% c("Literacy", "Student Attendance", "Beyond The Core"))
    print(paste("Rows remaining after dropping other indicators =", nrow(df)))

    # Since the ONLY data we actually care about here are the SQSS Indicator Scores, 
    # I'll drop those that are missing
    df <- filter(df, !is.na(INDICATOR_SCORE))
    print(paste("Rows remaining after dropping missing Indicator Scores =", nrow(df)))

    # Now that we've finished dropping invalid rows, we'll focus on column-level transformations. 

    # This particular data source includes some three digit SCHOOL_IDs that won't match others
    # We'll prepend a 0 to these to make them match other sources.
    df$SCHOOL_ID[nchar(df$SCHOOL_ID) == 3] <- paste0("0", df$SCHOOL_ID[nchar(df$SCHOOL_ID) == 3])

    # As above for the student-level data, we create our own unique SchoolID variable for Georgia
    df <- mutate(df, SchoolID = case_when(as.numeric(SYSTEM_ID) > 1000  ~ 
                                            paste0(SYSTEM_ID, GRADE_CLUSTER),
                                          TRUE ~ 
                                            paste0(as.numeric(SYSTEM_ID)*10000 + as.numeric(SCHOOL_ID), GRADE_CLUSTER)))

    # Then, I'll drop the columns we aren't interested in:
    df <- select(df, -c(SYSTEM_ID, SCHOOL_ID, SYSTEM_NAME, SCHOOL_NAME, GRADE_CLUSTER,
                        GRADE_CONFIGURATION, SCHOOL_YEAR))

    # Georgia has separate rows the three indicators, where we'll instead want different columns
    df <- pivot_wider(data = df,
                      id_cols = c("SchoolID", "REPORTING_LABEL"),
                      names_from = INDICATOR, 
                      values_from = INDICATOR_SCORE)

    print(paste("Final Rows =", nrow(df)))

    # Remove the spaces in the (new) column names
    df <- clean_names(df, case = "none")

    # We'll rename and rearrange
    df <- df %>% 
        # rename uses new_name = old_name syntax
        rename(Group = REPORTING_LABEL) %>%
        # change the order of the columns to be our standard form
        relocate(SchoolID, Group)

    # And finally, we'll standardise the group names
    df <- tidy_group_names(df)

    return(df)
}

schools_SQSS_18_tidied <- tidy_SQSS_data(schools_SQSS_18)
schools_SQSS_19_tidied <- tidy_SQSS_data(schools_SQSS_19)

rm(schools_SQSS_18, schools_SQSS_19, tidy_SQSS_data, tidy_group_names)
```

## Merge across school-level indicators

```{r merge_school_level_indicators}
# Explore missingness before and after the merge:
skim(schools_part_rates_18_tidied)
skim(schools_ProgELP_18_tidied)
skim(schools_SQSS_18_tidied)

# Join all three tables, keeping ALL rows (even if matches aren't found)
georgia_schools_2018 <-
    full_join(schools_part_rates_18_tidied,
              schools_ProgELP_18_tidied) %>%
        full_join(schools_SQSS_18_tidied)

skim(georgia_schools_2018)
rm(schools_part_rates_18_tidied, schools_ProgELP_18_tidied, schools_SQSS_18_tidied)

# Repeat for 2019 data
skim(schools_part_rates_19_tidied)
skim(schools_ProgELP_19_tidied) # Note: 2019 data for ProgELP ONLY reports for the "English Learner" group. 
skim(schools_SQSS_19_tidied)
georgia_schools_2019 <-
    full_join(schools_part_rates_19_tidied,
              schools_ProgELP_19_tidied) %>%
        full_join(schools_SQSS_19_tidied)

skim(georgia_schools_2019)
rm(schools_part_rates_19_tidied, schools_ProgELP_19_tidied, schools_SQSS_19_tidied)
```

## Checking for duplicates

Remove all school records with duplicate SchoolID, Level and Group combinations.

That is, if two or more records have the same SchoolID, Level and Group values, then all such records should be removed from the analysis.

```{r removing_school_level_duplicates}
test = get_dupes(georgia_schools_2018, SchoolID, Group)
nrow(test)

test = get_dupes(georgia_schools_2019, SchoolID, Group)
nrow(test)

rm(test)
```

## Sort the cleaned-up school data records, then output the final data. 

```{r sort__and_save_school_level_data}
georgia_schools_2018 <- georgia_schools_2018 %>%
    arrange(SchoolID, Group) %>%
    write_csv(file = "Data/Cleaned_Data/School_AcctData_Georgia_2018_EK.csv")

georgia_schools_2019 <- georgia_schools_2019 %>%
    arrange(SchoolID, Group) %>%
    write_csv(file = "Data/Cleaned_Data/School_AcctData_Georgia_2019_EK.csv")
```
